# Load the data
ufc_data <- read.csv("data/ufcdata.csv", stringsAsFactors = FALSE)
# Load the data
ufc_data <- read.csv("data/ufcdata.csv", stringsAsFactors = FALSE)
# Load the data
ufc_data <- read.csv("data/ufcdata.csv", stringsAsFactors = FALSE)
# Read in the cleaned dataset
ufc_clean <- read.csv("Data/ufc_clean.csv", stringsAsFactors = FALSE)
# Read in the original dataset
ufc_data <- read.csv("data/ufcdata.csv", stringsAsFactors = FALSE)
# Apply complete case analysis (removing rows with any missing values)
ufc_clean <- ufc_data[complete.cases(ufc_data), ]
# Check how many rows were retained
original_rows <- nrow(ufc_data)
clean_rows <- nrow(ufc_clean)
retention_rate <- (clean_rows / original_rows) * 100
# Print summary of the cleaning process
cat("Original dataset:", original_rows, "rows\n")
cat("Clean dataset:", clean_rows, "rows\n")
cat("Retention rate:", round(retention_rate, 2), "%\n")
# Save the cleaned dataset
write.csv(ufc_clean, "data/ufc_clean.csv", row.names = FALSE)
# Load necessary libraries
library(tidyverse)
# Read in the original dataset
ufc_data <- read.csv("data/ufcdata.csv", stringsAsFactors = FALSE)
# Apply complete case analysis (removing rows with any missing values)
ufc_clean <- ufc_data[complete.cases(ufc_data), ]
# Check how many rows were retained
original_rows <- nrow(ufc_data)
clean_rows <- nrow(ufc_clean)
retention_rate <- (clean_rows / original_rows) * 100
# Print summary of the cleaning process
cat("Original dataset:", original_rows, "rows\n")
cat("Clean dataset:", clean_rows, "rows\n")
cat("Retention rate:", round(retention_rate, 2), "%\n")
# Save the cleaned dataset
write.csv(ufc_clean, "data/ufc_clean.csv", row.names = FALSE)
# Read in the cleaned dataset (after complete case analysis)
ufc_clean_feature <- read.csv("data/ufc_clean.csv", stringsAsFactors = FALSE)
# 1. Physical Advantage Metrics
# Calculate differentials between fighters' physical attributes
ufc_clean_feature$height_advantage <- ufc_clean_feature$R_Height_cms - ufc_clean_feature$B_Height_cms
ufc_clean_feature$reach_advantage <- ufc_clean_feature$R_Reach_cms - ufc_clean_feature$B_Reach_cms
ufc_clean_feature$age_advantage <- ufc_clean_feature$R_age - ufc_clean_feature$B_age
ufc_clean_feature$weight_advantage <- ufc_clean_feature$R_Weight_lbs - ufc_clean_feature$B_Weight_lbs
# 2. Win Percentage and Experience Features
# Calculate win percentage for fighters with at least one previous bout
ufc_clean_feature$R_win_pct <- ifelse(ufc_clean_feature$R_wins + ufc_clean_feature$R_losses > 0,
ufc_clean_feature$R_wins / (ufc_clean_feature$R_wins + ufc_clean_feature$R_losses),
0.5)  # Default to 0.5 for fighters with no previous bouts
ufc_clean_feature$B_win_pct <- ifelse(ufc_clean_feature$B_wins + ufc_clean_feature$B_losses > 0,
ufc_clean_feature$B_wins / (ufc_clean_feature$B_wins + ufc_clean_feature$B_losses),
0.5)
ufc_clean_feature$win_pct_advantage <- ufc_clean_feature$R_win_pct - ufc_clean_feature$B_win_pct
ufc_clean_feature$experience_diff <- ufc_clean_feature$R_total_rounds_fought - ufc_clean_feature$B_total_rounds_fought
# 3. Performance Differential Metrics
# Striking metrics
ufc_clean_feature$striking_accuracy_diff <- ufc_clean_feature$R_avg_SIG_STR_pct - ufc_clean_feature$B_avg_SIG_STR_pct
ufc_clean_feature$striking_defense_diff <- (1-ufc_clean_feature$R_avg_opp_SIG_STR_pct) - (1-ufc_clean_feature$B_avg_opp_SIG_STR_pct)
# Grappling metrics
ufc_clean_feature$takedown_accuracy_diff <- ufc_clean_feature$R_avg_TD_pct - ufc_clean_feature$B_avg_TD_pct
ufc_clean_feature$takedown_defense_diff <- (1-ufc_clean_feature$R_avg_opp_TD_pct) - (1-ufc_clean_feature$B_avg_opp_TD_pct)
ufc_clean_feature$submission_attempts_diff <- ufc_clean_feature$R_avg_SUB_ATT - ufc_clean_feature$B_avg_SUB_ATT
# Impact metrics
ufc_clean_feature$knockdown_diff <- ufc_clean_feature$R_avg_KD - ufc_clean_feature$B_avg_KD
# 4. Style Indicator Features
# Calculate striking-to-grappling ratio (higher values indicate striker, lower values indicate grappler)
ufc_clean_feature$R_striking_to_grappling_ratio <- ifelse(ufc_clean_feature$R_avg_TD_att > 0,
ufc_clean_feature$R_avg_SIG_STR_att / ufc_clean_feature$R_avg_TD_att,
ufc_clean_feature$R_avg_SIG_STR_att)  # For fighters with zero TD attempts
ufc_clean_feature$B_striking_to_grappling_ratio <- ifelse(ufc_clean_feature$B_avg_TD_att > 0,
ufc_clean_feature$B_avg_SIG_STR_att / ufc_clean_feature$B_avg_TD_att,
ufc_clean_feature$B_avg_SIG_STR_att)
# Calculate offensive vs. defensive balance (higher values indicate offensive fighters)
ufc_clean_feature$R_offense_defense_ratio <- ufc_clean_feature$R_avg_SIG_STR_landed / (ufc_clean_feature$R_avg_opp_SIG_STR_landed + 0.1)  # Add small constant to avoid division by zero
ufc_clean_feature$B_offense_defense_ratio <- ufc_clean_feature$B_avg_SIG_STR_landed / (ufc_clean_feature$B_avg_opp_SIG_STR_landed + 0.1)
ufc_clean_feature$offense_defense_diff <- ufc_clean_feature$R_offense_defense_ratio - ufc_clean_feature$B_offense_defense_ratio
# 5. Create categorical style variables (optional)
# These can be used for style matchup analysis
ufc_clean_feature$R_style <- case_when(
ufc_clean_feature$R_striking_to_grappling_ratio > 20 ~ "Striker",
ufc_clean_feature$R_striking_to_grappling_ratio < 10 ~ "Grappler",
TRUE ~ "Balanced"
)
ufc_clean_feature$B_style <- case_when(
ufc_clean_feature$B_striking_to_grappling_ratio > 20 ~ "Striker",
ufc_clean_feature$B_striking_to_grappling_ratio < 10 ~ "Grappler",
TRUE ~ "Balanced"
)
ufc_clean_feature$R_approach <- case_when(
ufc_clean_feature$R_offense_defense_ratio > 1.5 ~ "Offensive",
ufc_clean_feature$R_offense_defense_ratio < 0.7 ~ "Defensive",
TRUE ~ "Balanced"
)
ufc_clean_feature$B_approach <- case_when(
ufc_clean_feature$B_offense_defense_ratio > 1.5 ~ "Offensive",
ufc_clean_feature$B_offense_defense_ratio < 0.7 ~ "Defensive",
TRUE ~ "Balanced"
)
# 6. Prepare target variable for modeling
ufc_clean_feature$target <- ifelse(ufc_clean_feature$Winner == "Red", 1, 0)
# Save the feature-engineered dataset
write.csv(ufc_clean_feature, "data/ufc_features.csv", row.names = FALSE)
# Save the feature-engineered dataset
write.csv(ufc_clean_feature, "data/ufc_features.csv", row.names = FALSE)
# Print summary of created features
cat("Feature engineering complete. Created", ncol(ufc_clean_feature) - ncol(read.csv("data/ufc_clean_feature.csv")),
"new features.\n")
# Save the feature-engineered dataset
write.csv(ufc_clean_feature, "data/ufc_clean_features.csv", row.names = FALSE)
# Print summary of created features
cat("Feature engineering complete. Created", ncol(ufc_clean_feature) - ncol(read.csv("data/ufc_clean_feature.csv")),
"new features.\n")
# Load necessary libraries
library(ggplot2)
library(gridExtra)
library(dplyr)
library(tidyr)
# Create mock importance data for logistic regression (based on z-values)
log_importance <- data.frame(
Variable = c("age_advantage", "striking_defense_diff", "R_avg_SIG_STR_pct",
"R_avg_TD_pct", "R_avg_SUB_ATT"),
Importance = c(9.775, 4.297, 2.638, 2.574, 2.413),
Model = "Logistic Regression"
)
# Create mock importance data for random forest (based on Mean Decrease Gini)
rf_importance <- data.frame(
Variable = c("offense_defense_diff", "age_advantage", "R_striking_to_grappling_ratio",
"striking_defense_diff", "B_striking_to_grappling_ratio",
"striking_accuracy_diff", "takedown_defense_diff",
"R_avg_SIG_STR_pct", "experience_diff", "takedown_accuracy_diff"),
Importance = c(88.79, 81.95, 76.50, 74.33, 70.78, 70.06, 68.60, 68.44, 64.43, 64.19),
Model = "Random Forest"
)
# Normalize importance scores for fair comparison
log_importance$Importance_Normalized <- log_importance$Importance / max(log_importance$Importance)
rf_importance$Importance_Normalized <- rf_importance$Importance / max(rf_importance$Importance)
# Select top features from both models
top_features <- unique(c(
log_importance$Variable,
rf_importance$Variable[1:10]
))
# Create a comparison data frame
importance_comparison <- data.frame(
Variable = top_features,
LogisticRegression = 0,
RandomForest = 0
)
# Fill in the normalized importance values
for (var in top_features) {
if (var %in% log_importance$Variable) {
importance_comparison$LogisticRegression[importance_comparison$Variable == var] <-
log_importance$Importance_Normalized[log_importance$Variable == var]
}
if (var %in% rf_importance$Variable) {
importance_comparison$RandomForest[importance_comparison$Variable == var] <-
rf_importance$Importance_Normalized[rf_importance$Variable == var]
}
}
# Reshape for plotting
importance_comparison_long <- importance_comparison %>%
pivot_longer(cols = c(LogisticRegression, RandomForest),
names_to = "Model",
values_to = "Importance")
# Create individual plots for each model
log_plot <- ggplot(log_importance %>% arrange(desc(Importance)),
aes(x = reorder(Variable, Importance), y = Importance)) +
geom_bar(stat = "identity", fill = "steelblue") +
coord_flip() +
labs(title = "Top Important Features (Logistic Regression)",
x = "Feature",
y = "Importance (|z-value|)") +
theme_minimal() +
theme(plot.title = element_text(size = 12, face = "bold"),
axis.text.y = element_text(size = 10))
rf_plot <- ggplot(rf_importance %>% head(10) %>% arrange(desc(Importance)),
aes(x = reorder(Variable, Importance), y = Importance)) +
geom_bar(stat = "identity", fill = "darkgreen") +
coord_flip() +
labs(title = "Top Important Features (Random Forest)",
x = "Feature",
y = "Importance (Mean Decrease Gini)") +
theme_minimal() +
theme(plot.title = element_text(size = 12, face = "bold"),
axis.text.y = element_text(size = 10))
# Create comparison plot
comparison_plot <- ggplot(importance_comparison_long,
aes(x = reorder(Variable, Importance),
y = Importance,
fill = Model)) +
geom_bar(stat = "identity", position = "dodge") +
coord_flip() +
scale_fill_manual(values = c("LogisticRegression" = "steelblue",
"RandomForest" = "darkgreen")) +
labs(title = "Variable Importance Comparison",
subtitle = "Normalized importance scores across both models",
x = "Feature",
y = "Normalized Importance") +
theme_minimal() +
theme(legend.position = "bottom",
plot.title = element_text(size = 14, face = "bold"),
axis.text.y = element_text(size = 10))
# Arrange plots side by side and below
grid.arrange(
arrangeGrob(log_plot, rf_plot, ncol = 2),
comparison_plot,
nrow = 2,
heights = c(1, 1.2)
)
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(lubridate)
# Assuming your dataframe is called ufc_clean_features
# First convert date to proper date format and extract year
ufc_data <- ufc_clean_features %>%
mutate(date = as.Date(date),
year = year(date)) %>%
# Count wins by year and corner
group_by(year) %>%
summarize(
red_wins = sum(Winner == "Red"),
total_fights = n(),
red_win_pct = red_wins / total_fights * 100,
.groups = "drop"
)
# Create the plot
ggplot(ufc_data, aes(x = year, y = red_win_pct)) +
geom_line(color = "black") +
geom_point(aes(size = total_fights), color = "black", alpha = 0.8) +
scale_size_continuous(range = c(3, 8), name = "Total Fights") +
scale_x_continuous(breaks = seq(min(ufc_data$year), max(ufc_data$year), by = 5)) +
scale_y_continuous(limits = c(50, 100), name = "Red (%)") +
labs(title = "Red Fighter Win Percentage by Year",
x = "Year") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0, face = "bold"),
legend.position = "right",
panel.grid.minor = element_blank()
)
# Assuming your dataframe is called ufc_clean_features
# First convert date to proper date format and extract year
ufc_data <- ufc_clean_features %>%
mutate(date = as.Date(date),
year = year(date)) %>%
# Count wins by year and corner
group_by(year) %>%
summarize(
red_wins = sum(Winner == "Red"),
total_fights = n(),
red_win_pct = red_wins / total_fights * 100,
.groups = "drop"
)
# Create the plot
ggplot(ufc_data, aes(x = year, y = red_win_pct)) +
geom_line(color = "black") +
geom_point(aes(size = total_fights), color = "black", alpha = 0.8) +
scale_size_continuous(range = c(3, 8), name = "Total Fights") +
scale_x_continuous(breaks = seq(min(ufc_data$year), max(ufc_data$year), by = 5)) +
scale_y_continuous(limits = c(50, 100), name = "Red (%)") +
labs(title = "Red Fighter Win Percentage by Year",
x = "Year") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0, face = "bold"),
legend.position = "right",
panel.grid.minor = element_blank()
)
# Assuming your dataframe is called ufc_clean_features
# First convert date to proper date format and extract year
ufc_data <- ufc_clean_features %>%
mutate(date = as.Date(date),
year = year(date)) %>%
# Count wins by year and corner
group_by(year) %>%
summarize(
red_wins = sum(Winner == "Red"),
total_fights = n(),
red_win_pct = red_wins / total_fights * 100,
.groups = "drop"
)
ufc_clean_features <- read.csv("data/ufc_clean_features.csv", stringsAsFactors = FALSE)
# Assuming your dataframe is called ufc_clean_features
# First convert date to proper date format and extract year
ufc_data <- ufc_clean_features %>%
mutate(date = as.Date(date),
year = year(date)) %>%
# Count wins by year and corner
group_by(year) %>%
summarize(
red_wins = sum(Winner == "Red"),
total_fights = n(),
red_win_pct = red_wins / total_fights * 100,
.groups = "drop"
)
# Create the plot
ggplot(ufc_data, aes(x = year, y = red_win_pct)) +
geom_line(color = "black") +
geom_point(aes(size = total_fights), color = "black", alpha = 0.8) +
scale_size_continuous(range = c(3, 8), name = "Total Fights") +
scale_x_continuous(breaks = seq(min(ufc_data$year), max(ufc_data$year), by = 5)) +
scale_y_continuous(limits = c(50, 100), name = "Red (%)") +
labs(title = "Red Fighter Win Percentage by Year",
x = "Year") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0, face = "bold"),
legend.position = "right",
panel.grid.minor = element_blank()
)
